安卓加固方式 
======================================
1.  混淆化   
  	1. 标识符混淆   
		   标识符混淆就是对源程序中的包名、类名、方法名和变量名进行重命名，
		   用无意义的标识符来替换，使得破解这分析起来更困难。
		   最常用的就是ProGuard开源工具，其混淆后效果如右图所示。   
		   好处： 很难用自动化来反混淆，智能是人工根据源代码猜测。   
    2. 控制流（control flow）   
		   就是在不改变源代码的功能前提下，将if、while、for、do等控制语句转换成switch分支语句。     
		   好处: 可以模糊switch中case代码块之间的关系, 在静态分析的时候会不能确定那个case条件首先执行从而增加分析难度。
    3. 花指令 （junk instruction）   
		   花指令也叫垃圾指令，是指在原始程序中插入一组无用的字节，但又不会改变程序的原始逻辑，
		   程序仍然可以正常运行，然而反汇编工具在反汇编这些字节时会出错，由此造成反汇编工具失效，提高破解难度。   
		   好处：有效的防止自动化反编译工具。让攻击者消耗更多的时间。 
    4. 字符串混淆( string obfuscate )    
       (1) 编码混淆   
           编码混淆就是先将字符串转换成16进制的数组或者Unicode编码，在使用的时候才恢复成字符串。
           这样破解者在逆向后看到的是一串数字或者乱码，很难直接分析。   
		   (2) 加密处理   
			     加密处理就是实现在本地将字符串加密，然后将密文硬编码到源程序中，
			     再实现一个解密函数，在引用密文的地方调用解密函数解密即可    
		   好处：让攻击者不能直接好简洁的根据字符串来推测位置。
2. 加密
    1. 加密dex文件后隐藏到文件里。    
	    1. java层/native层加固脱壳方式   
		    把原dex加密后隐藏到新的文件里或者已存在的文件后面
		    根据文件不同修改headset加入大小，offset等数据
        脱壳程序可在java层或者native层。(使用dexClassLoader)
   2. 加固so文件
      1. 压缩so文件   
          - 使用lzma压缩方式   
          - 编写解压和加载 so的程序   
          - 把压缩后的原so数据加载到loader文件里最后section后面   
          - Program Header 中的文件大小和加载到内存里的大小即可。   
            ELF 头部中与 Section 里写入压缩数据的大小和偏移了   
      2. 加密so的section   
        使用“ __attribute__((section(".mytext"))” 把对象函数放到之定义的.mytext段   
        使用“__attribute(constructor)”属性把解密函数在main函数运行前执行可以第一时间解密。   
        先把没有加密后的so文件生成。   
        使用脚本对so文件.mytext段进行加密后在把加密的地址，偏移，大小存到头部文件（选择不会影响的地方 e_entry，e_shoff、e_shentsize、e_shnum和e_shstrndx）   
        ps：因为修改了头部文件所以分析的时候反编译软件会显示出错（很好的反编译方式）

      3. 加密so里函数   
        每个函数的结构描述是存放在.dynsym段 dynamic symbol map 动态符号表   
        每个函数名称保存在.dynstr段中	dynamic string 动态字符串表
        在ELF格式中有一个.hash段
        使用哈希函数把加密的函数名字哈希后在.hash表上搜索 (bucket, chain)
        得到加密后的函数的地址，大小，偏移等信息
3. llvm混淆化   
    1. native 混淆  
